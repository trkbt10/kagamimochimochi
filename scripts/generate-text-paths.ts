import opentype from 'opentype.js'
import fs from 'fs'
import path from 'path'

const TEXT_BUILDER_DIR = 'src/text-builder'
const CONFIG_PATH = path.join(TEXT_BUILDER_DIR, 'config/text-config.json')
const OUTPUT_PATH = path.join(TEXT_BUILDER_DIR, 'generated/text-paths.ts')

interface TextConfig {
  font: {
    family: string
    weight: string
    path: string
  }
  texts: string[]
}

const config: TextConfig = JSON.parse(fs.readFileSync(CONFIG_PATH, 'utf-8'))

async function generatePaths() {
  const fontPath = path.join(TEXT_BUILDER_DIR, config.font.path)

  console.log(`Loading font from: ${fontPath}`)
  const font = await opentype.load(fontPath)

  const paths: Record<string, string> = {}

  for (const text of config.texts) {
    console.log(`Generating path for: ${text}`)

    // テキストをSVGパスに変換
    const textPath = font.getPath(text, 0, 0, 72) // fontSize = 72
    const svgPathData = textPath.toSVG(2) // precision = 2

    // バウンディングボックスを取得
    const bounds = textPath.getBoundingBox()
    const width = bounds.x2 - bounds.x1
    const height = bounds.y2 - bounds.y1

    // svgPathDataは <path d="..."/> 形式
    // fill属性を追加してSVGLoaderが認識できるようにする
    const svgPathWithFill = svgPathData.replace('<path ', '<path fill="#000000" ')
    const svg = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="${bounds.x1} ${bounds.y1} ${width} ${height}">${svgPathWithFill}</svg>`

    paths[text] = svg
  }

  // 出力ディレクトリ作成
  fs.mkdirSync(path.dirname(OUTPUT_PATH), { recursive: true })

  // TypeScriptファイルとして出力
  const output = `// Auto-generated by scripts/generate-text-paths.ts
// Do not edit manually

export const TEXT_PATHS: Record<string, string> = ${JSON.stringify(paths, null, 2)}
`

  fs.writeFileSync(OUTPUT_PATH, output)
  console.log(`Generated ${config.texts.length} text paths to ${OUTPUT_PATH}`)
}

generatePaths().catch(console.error)

import opentype from 'opentype.js'
import fs from 'fs'
import path from 'path'

const TEXT_BUILDER_DIR = 'src/text-builder'
const CONFIG_PATH = path.join(TEXT_BUILDER_DIR, 'config/text-config.json')
const OUTPUT_PATH = path.join(TEXT_BUILDER_DIR, 'generated/text-paths.ts')

// 視覚的重みを下げる記号（句読点、感嘆符など）
const LIGHT_WEIGHT_CHARS = new Set([
  '！', '!', '？', '?', '。', '、', '・', '…', '～', '〜',
  '「', '」', '『', '』', '（', '）', '(', ')', '【', '】'
])

// 記号の重み係数（0に近いほど重心計算で無視される）
const SYMBOL_WEIGHT = 0.2

interface TextEntry {
  text: string
  originX?: number
}

interface TextConfig {
  font: {
    family: string
    weight: string
    path: string
  }
  texts: Array<string | TextEntry>
}

interface TextPathData {
  svg: string
  originX: number
  originY: number
}

const config: TextConfig = JSON.parse(fs.readFileSync(CONFIG_PATH, 'utf-8'))

/**
 * 視覚的重心を計算する
 * 各グリフの幅と位置を考慮し、記号は重みを下げる
 */
function calculateVisualCenter(
  font: opentype.Font,
  text: string,
  fontSize: number,
  manualOriginX?: number
): { originX: number; originY: number; bounds: opentype.BoundingBox } {
  const textPath = font.getPath(text, 0, 0, fontSize)
  const bounds = textPath.getBoundingBox()

  // Y方向は単純に中央
  const originY = (bounds.y1 + bounds.y2) / 2

  // 手動指定がある場合はそれを使用
  if (manualOriginX !== undefined) {
    const originX = bounds.x1 + (bounds.x2 - bounds.x1) * manualOriginX
    return { originX, originY, bounds }
  }

  // 各グリフの位置と重みを計算
  let weightedSum = 0
  let totalWeight = 0
  let currentX = 0

  for (const char of text) {
    const glyph = font.charToGlyph(char)
    const advanceWidth = (glyph.advanceWidth || 0) * (fontSize / font.unitsPerEm)

    // グリフの中心位置
    const glyphCenterX = currentX + advanceWidth / 2

    // 記号かどうかで重みを決定
    const weight = LIGHT_WEIGHT_CHARS.has(char) ? SYMBOL_WEIGHT : 1.0

    weightedSum += glyphCenterX * weight * advanceWidth
    totalWeight += weight * advanceWidth

    currentX += advanceWidth
  }

  // 重み付き平均で視覚的重心を計算
  const originX = totalWeight > 0 ? weightedSum / totalWeight : (bounds.x1 + bounds.x2) / 2

  return { originX, originY, bounds }
}

async function generatePaths() {
  const fontPath = path.join(TEXT_BUILDER_DIR, config.font.path)

  console.log(`Loading font from: ${fontPath}`)
  const font = await opentype.load(fontPath)

  const pathData: Record<string, TextPathData> = {}
  const fontSize = 72

  for (const entry of config.texts) {
    // 文字列またはオブジェクト形式を処理
    const text = typeof entry === 'string' ? entry : entry.text
    const manualOriginX = typeof entry === 'object' ? entry.originX : undefined

    console.log(`Generating path for: ${text}`)

    // テキストをSVGパスに変換
    const textPath = font.getPath(text, 0, 0, fontSize)
    const svgPathData = textPath.toSVG(2) // precision = 2

    // 視覚的重心を計算
    const { originX, originY, bounds } = calculateVisualCenter(font, text, fontSize, manualOriginX)

    const width = bounds.x2 - bounds.x1
    const height = bounds.y2 - bounds.y1

    // svgPathDataは <path d="..."/> 形式
    // fill属性を追加してSVGLoaderが認識できるようにする
    const svgPathWithFill = svgPathData.replace('<path ', '<path fill="#000000" ')
    const svg = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="${bounds.x1} ${bounds.y1} ${width} ${height}">${svgPathWithFill}</svg>`

    pathData[text] = {
      svg,
      originX,
      originY
    }

    console.log(`  Visual center: (${originX.toFixed(2)}, ${originY.toFixed(2)})`)
    console.log(`  Geometric center: (${((bounds.x1 + bounds.x2) / 2).toFixed(2)}, ${((bounds.y1 + bounds.y2) / 2).toFixed(2)})`)
  }

  // 出力ディレクトリ作成
  fs.mkdirSync(path.dirname(OUTPUT_PATH), { recursive: true })

  // TypeScriptファイルとして出力
  const output = `// Auto-generated by scripts/generate-text-paths.ts
// Do not edit manually

import type { TextPathData } from '../types'

/** テキストパスデータ（SVG + 視覚的重心情報） */
export const TEXT_PATH_DATA: Record<string, TextPathData> = ${JSON.stringify(pathData, null, 2)}
`

  fs.writeFileSync(OUTPUT_PATH, output)
  console.log(`Generated ${config.texts.length} text paths to ${OUTPUT_PATH}`)
}

generatePaths().catch(console.error)
